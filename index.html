<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HSK 5 Vocabulary Quiz</title>
    <!-- QR Code Library -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
    <!-- LZ-String Compression Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
    <style>
        /* Your existing CSS remains exactly the same, adding new styles for navigation */
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-card: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #666;
            --accent: #3498db;
            --success: #2ecc71;
            --error: #e74c3c;
            --warning: #f39c12;
            --border: #e9ecef;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-card: #333333;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --accent: #4a9eff;
            --success: #00d084;
            --error: #ff6b6b;
            --warning: #ffa726;
            --border: #444444;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            transition: all 0.3s ease;
            padding: 0;
            overflow-x: hidden;
        }

        .container {
            width: 100%;
            min-height: 100vh;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
        }

        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border);
            border-top: 4px solid var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loading-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .error-message {
            background: var(--error);
            color: white;
            padding: 16px;
            border-radius: 8px;
            margin: 16px;
            text-align: center;
            display: none;
        }

        /* Header */
        .header {
            background: var(--accent);
            color: white;
            padding: 12px 16px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .title {
            font-size: 1.4rem;
            font-weight: 700;
        }

        .theme-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .subtitle {
            font-size: 0.85rem;
            opacity: 0.9;
        }

        /* Quick Stats */
        .quick-stats {
            display: flex;
            justify-content: space-around;
            background: var(--bg-secondary);
            padding: 12px 8px;
            border-bottom: 1px solid var(--border);
        }

        .stat-item {
            text-align: center;
            flex: 1;
        }

        .stat-number {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        /* Progress Bar */
        .progress-container {
            background: var(--bg-secondary);
            height: 8px;
            position: relative;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--accent));
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            padding: 16px;
            display: flex;
            flex-direction: column;
        }

        /* Controls */
        .top-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            gap: 4px;
            background: var(--bg-card);
            border-radius: 8px;
            padding: 4px;
            border: 1px solid var(--border);
        }

        .mode-btn, .batch-btn, .action-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            background: transparent;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .mode-btn.active, .batch-btn.active {
            background: var(--accent);
            color: white;
            box-shadow: 0 2px 4px var(--shadow);
        }

        .action-btn {
            background: var(--accent);
            color: white;
        }

        .secondary-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        /* Question Area */
        .question-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 300px;
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px var(--shadow);
            margin-bottom: 16px;
            border: 1px solid var(--border);
        }

        .question {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            color: var(--text-primary);
            margin-bottom: 24px;
            min-height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
        }

        .feedback {
            text-align: center;
            font-size: 1rem;
            font-weight: 600;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 16px;
            border-radius: 8px;
            padding: 8px 12px;
            transition: all 0.3s ease;
        }

        .feedback.correct {
            background: rgba(46, 204, 113, 0.1);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .feedback.incorrect {
            background: rgba(231, 76, 60, 0.1);
            color: var(--error);
            border: 1px solid var(--error);
        }

        /* Options */
        .options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }

        .option {
            padding: 16px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 500;
            transition: all 0.2s ease;
            text-align: center;
            position: relative;
            overflow: hidden;
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 70px;
        }

        .option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .option:active {
            transform: scale(0.98);
        }

        .option.selected {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            transform: scale(1.02);
        }

        .option.correct {
            background: var(--success);
            color: white;
            border-color: var(--success);
            animation: pulse 0.6s ease;
        }

        .option.incorrect {
            background: var(--error);
            color: white;
            border-color: var(--error);
            animation: shake 0.5s ease;
        }

        /* Option content styling for better mobile display */
        .option-pinyin {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .option-english {
            font-size: 0.9rem;
            opacity: 0.9;
            line-height: 1.3;
        }

        /* Review Section */
        .review-section {
            margin-top: 20px;
            padding: 16px;
            background: var(--bg-card);
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow);
            border: 1px solid var(--border);
            display: none;
        }

        .review-header {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .review-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }

        .review-item {
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .review-chinese {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .review-pinyin {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .review-english {
            font-size: 1rem;
            color: var(--text-primary);
        }

        .review-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 16px;
            gap: 8px;
        }

        /* Completion Screen */
        .completion-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .completion-content {
            background: var(--bg-card);
            padding: 24px;
            border-radius: 12px;
            text-align: center;
            max-width: 90%;
            width: 400px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .completion-title {
            font-size: 1.8rem;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .completion-stats {
            margin-bottom: 24px;
        }

        .completion-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid var(--border);
        }

        /* Batch Navigation */
        .batch-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 16px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .batch-info {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .batch-buttons {
            display: flex;
            gap: 8px;
        }

        /* Progress Overview */
        .progress-overview {
            margin-top: 16px;
            padding: 16px;
            background: var(--bg-card);
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow);
            border: 1px solid var(--border);
            display: none;
        }

        .progress-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .batch-progress {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px;
        }

        .batch-progress-item {
            padding: 8px;
            background: var(--bg-secondary);
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .batch-progress-item.current {
            background: var(--accent);
            color: white;
        }

        .batch-progress-item.completed {
            background: var(--success);
            color: white;
        }

        .batch-progress-item.review {
            background: var(--warning);
            color: white;
        }

        /* Share Progress Modal */
        .share-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .share-content {
            background: var(--bg-card);
            padding: 24px;
            border-radius: 12px;
            text-align: center;
            max-width: 90%;
            width: 400px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .share-title {
            font-size: 1.5rem;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .share-url {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin: 16px 0;
            word-break: break-all;
            font-size: 0.9rem;
            text-align: left;
            max-height: 100px;
            overflow-y: auto;
        }

        .qr-container {
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            display: inline-block;
        }

        .share-actions {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 16px;
        }

        /* Analysis Dashboard */
        .analysis-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .analysis-content {
            background: var(--bg-card);
            padding: 24px;
            border-radius: 12px;
            max-width: 95%;
            width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .analysis-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: var(--text-primary);
            text-align: center;
        }

        .analysis-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .analysis-stat-card {
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .analysis-stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 4px;
        }

        .analysis-stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .analysis-section {
            margin-bottom: 24px;
        }

        .analysis-section-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
            border-bottom: 2px solid var(--accent);
            padding-bottom: 6px;
        }

        .batch-performance {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
        }

        .batch-performance-item {
            background: var(--bg-secondary);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .batch-performance-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow);
        }

        .batch-performance-item.current {
            border: 2px solid var(--accent);
        }

        .batch-performance-item.completed {
            border-left: 4px solid var(--success);
        }

        .batch-performance-item.in-progress {
            border-left: 4px solid var(--warning);
        }

        .batch-performance-item.not-started {
            border-left: 4px solid var(--border);
            opacity: 0.7;
        }

        .batch-number {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .batch-accuracy {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .batch-stats {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .weak-words-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .weak-word-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .weak-word-chinese {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .weak-word-stats {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .weak-word-accuracy {
            font-weight: bold;
            color: var(--error);
        }

        .analysis-actions {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 20px;
        }

        /* Navigation Controls */
        .navigation-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 16px;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .navigation-controls.visible {
            opacity: 1;
        }

        .nav-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .nav-btn:hover:not(:disabled) {
            background: var(--accent);
            color: white;
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .nav-btn.hidden {
            display: none;
        }

        /* Sync Indicator */
        .sync-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--success);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            z-index: 1001;
            display: none;
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            75% { transform: translateX(8px); }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Enhanced Mobile Responsiveness */
        @media (max-width: 768px) {
            .header {
                padding: 10px 12px;
            }

            .header-top {
                flex-wrap: wrap;
            }

            .title {
                font-size: 1.3rem;
                flex: 1;
                min-width: 0;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .theme-toggle {
                width: 36px;
                height: 36px;
                font-size: 1.1rem;
            }

            .quick-stats {
                padding: 10px 4px;
            }

            .stat-number {
                font-size: 1.2rem;
            }

            .stat-label {
                font-size: 0.7rem;
            }

            .top-controls {
                gap: 6px;
                margin-bottom: 12px;
            }

            .control-group {
                flex: 1;
                min-width: 0;
                justify-content: center;
            }

            .mode-btn, .batch-btn, .action-btn {
                padding: 8px 10px;
                font-size: 0.8rem;
                flex: 1;
                min-width: 0;
                text-align: center;
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .question-container {
                padding: 16px;
                min-height: 200px;
                margin-bottom: 12px;
            }

            .question {
                font-size: 1.8rem;
                min-height: 60px;
                margin-bottom: 16px;
            }

            .options {
                gap: 8px;
            }

            .option {
                padding: 12px 10px;
                font-size: 1rem;
                min-height: 70px;
                display: flex;
                align-items: center;
                justify-content: center;
                flex-direction: column;
            }

            .option-pinyin {
                font-size: 1rem;
                font-weight: 600;
                margin-bottom: 4px;
            }

            .option-english {
                font-size: 0.85rem;
                opacity: 0.9;
                line-height: 1.2;
            }

            .batch-navigation {
                flex-direction: column;
                gap: 12px;
                padding: 10px;
            }

            .batch-buttons {
                width: 100%;
                display: flex;
                gap: 8px;
            }

            .batch-buttons .action-btn {
                flex: 1;
            }

            .review-section,
            .progress-overview {
                padding: 12px;
            }

            .review-header {
                font-size: 1.1rem;
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }

            .review-item {
                padding: 10px;
            }

            .review-chinese {
                font-size: 1.3rem;
            }

            .completion-content {
                width: 95%;
                padding: 20px;
                margin: 10px;
            }

            .completion-title {
                font-size: 1.5rem;
            }

            .share-content {
                width: 95%;
                padding: 16px;
            }

            .share-title {
                font-size: 1.3rem;
            }

            .share-url {
                font-size: 0.8rem;
                padding: 10px;
            }

            .qr-container {
                padding: 10px;
                max-width: 200px;
                margin: 10px auto;
            }

            .analysis-content {
                width: 98%;
                padding: 12px;
                margin: 10px;
            }

            .analysis-title {
                font-size: 1.5rem;
            }

            .analysis-stats {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .analysis-stat-card {
                padding: 12px;
            }

            .analysis-stat-number {
                font-size: 1.5rem;
            }

            .batch-performance {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 8px;
            }

            .batch-progress {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 6px;
            }

            .navigation-controls {
                flex-direction: column;
            }

            .nav-btn {
                min-height: 44px;
            }

            .subtitle {
                display: none;
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 8px 10px;
            }

            .title {
                font-size: 1.1rem;
            }

            .main-content {
                padding: 8px;
            }

            .top-controls {
                flex-direction: column;
            }

            .control-group {
                width: 100%;
            }

            .mode-btn, .batch-btn, .action-btn {
                padding: 10px 8px;
                font-size: 0.75rem;
                min-height: 44px;
            }

            .question-container {
                padding: 12px;
                min-height: 180px;
                border-radius: 10px;
            }

            .question {
                font-size: 1.6rem;
                min-height: 50px;
                margin-bottom: 12px;
            }

            .feedback {
                font-size: 0.9rem;
                min-height: 40px;
                padding: 6px 8px;
            }

            .option {
                padding: 10px 8px;
                font-size: 0.9rem;
                min-height: 65px;
                border-radius: 10px;
                font-size: 16px;
            }

            .option-pinyin {
                font-size: 0.95rem;
            }

            .option-english {
                font-size: 0.8rem;
            }

            .quick-stats {
                padding: 8px 2px;
            }

            .stat-number {
                font-size: 1.1rem;
            }

            .stat-label {
                font-size: 0.65rem;
            }

            .batch-navigation {
                padding: 8px;
            }

            .batch-info {
                font-size: 0.8rem;
                text-align: center;
            }

            .review-section,
            .progress-overview {
                padding: 10px;
            }

            .review-header {
                font-size: 1rem;
            }

            .review-chinese {
                font-size: 1.2rem;
            }

            .review-pinyin {
                font-size: 0.9rem;
            }

            .review-english {
                font-size: 0.9rem;
            }

            .completion-content {
                padding: 16px;
            }

            .completion-title {
                font-size: 1.3rem;
            }

            .completion-stat {
                font-size: 0.9rem;
            }

            .analysis-stats {
                grid-template-columns: 1fr;
            }

            .analysis-stat-card {
                padding: 10px;
            }

            .analysis-stat-number {
                font-size: 1.3rem;
            }

            .batch-performance {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 6px;
            }

            .batch-progress {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
                gap: 4px;
            }

            .share-actions,
            .analysis-actions,
            .review-actions {
                flex-direction: column;
                gap: 6px;
            }

            .share-actions .action-btn,
            .analysis-actions .action-btn,
            .review-actions .action-btn {
                width: 100%;
            }
        }

        /* Additional mobile-specific improvements */
        @media (max-width: 768px) and (orientation: landscape) {
            .header {
                padding: 6px 10px;
            }

            .title {
                font-size: 1.1rem;
            }

            .quick-stats {
                padding: 6px 2px;
            }

            .question-container {
                min-height: 150px;
                padding: 12px;
            }

            .question {
                font-size: 1.5rem;
                min-height: 40px;
                margin-bottom: 10px;
            }

            .options {
                gap: 6px;
            }

            .option {
                padding: 8px 6px;
                font-size: 0.85rem;
                min-height: 60px;
            }

            .option-pinyin {
                font-size: 0.9rem;
            }

            .option-english {
                font-size: 0.75rem;
            }
        }

        /* Prevent zoom on input for iOS */
        @media (max-width: 768px) {
            .option {
                font-size: 16px;
            }
        }

        /* Touch-friendly improvements */
        .option {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .action-btn, .mode-btn, .batch-btn {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Improved loading for mobile */
        @media (max-width: 768px) {
            .loading-text {
                font-size: 1rem;
                text-align: center;
                padding: 0 20px;
            }

            .loading-spinner {
                width: 40px;
                height: 40px;
            }
        }

        /* Better scroll experience on mobile */
        @media (max-width: 768px) {
            .share-url {
                max-height: 80px;
            }

            .analysis-content {
                max-height: 85vh;
            }
        }
    </style>
</head>
<body data-theme="light">
    <!-- Loading Screen -->
    <div class="loading-screen" id="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading HSK vocabulary...</div>
    </div>

    <!-- Error Message -->
    <div class="error-message" id="error-message">
        Failed to load vocabulary. Please check that the vocabulary.json file is in the correct location.
    </div>

    <!-- Sync Indicator -->
    <div class="sync-indicator" id="sync-indicator">Progress Saved</div>

    <div class="container" style="display: none;" id="main-container">
        <!-- Header -->
        <header class="header">
            <div class="header-top">
                <h1 class="title">HSK 5 Quiz</h1>
                <button class="theme-toggle" id="theme-toggle" title="Toggle theme">
                    <span id="theme-icon">üåô</span>
                </button>
            </div>
            <p class="subtitle">Match Chinese characters to pinyin and English translations</p>
        </header>

        <!-- Quick Stats -->
        <div class="quick-stats">
            <div class="stat-item">
                <div class="stat-number" id="current-question">1</div>
                <div class="stat-label">Current</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="correct-count">0</div>
                <div class="stat-label">Correct</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="wrong-count">0</div>
                <div class="stat-label">Wrong</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="accuracy">0%</div>
                <div class="stat-label">Accuracy</div>
            </div>
        </div>

        <!-- Progress Bar -->
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Controls -->
            <div class="top-controls">
                <div class="control-group">
                    <button class="mode-btn active" id="mode-pinyin">üî§ Pinyin</button>
                    <button class="mode-btn" id="mode-english">üá∫üá∏ English</button>
                </div>
                <div class="control-group">
                    <button class="batch-btn" data-size="25">25</button>
                    <button class="batch-btn active" data-size="50">50</button>
                    <button class="batch-btn" data-size="100">100</button>
                    <button class="batch-btn" data-size="all">All</button>
                </div>
                <div class="control-group">
                    <button class="action-btn secondary-btn" id="review-wrong-btn" style="display: none;">
                        üìù Review
                    </button>
                    <button class="action-btn secondary-btn" id="progress-overview-btn">
                        üìä Progress
                    </button>
                    <button class="action-btn secondary-btn" id="analysis-btn">
                        üìà Analysis
                    </button>
                    <button class="action-btn secondary-btn" id="save-progress-btn">
                        üíæ Save
                    </button>
                    <button class="action-btn secondary-btn" id="share-progress-btn">
                        üîó Share
                    </button>
                </div>
            </div>

            <!-- Question Container -->
            <div class="question-container fade-in">
                <div class="question" id="question">Loading...</div>
                <div class="feedback" id="feedback"></div>
                <div class="options" id="options"></div>

                <!-- Navigation Controls -->
                <div class="navigation-controls" id="navigation-controls">
                    <button class="nav-btn hidden" id="previous-question-btn" disabled>
                        <span>‚¨ÖÔ∏è</span> Previous
                    </button>
                    <button class="nav-btn hidden" id="forward-question-btn" disabled>
                        Forward <span>‚û°Ô∏è</span>
                    </button>
                </div>
            </div>

            <!-- Batch Navigation -->
            <div class="batch-navigation">
                <div class="batch-info" id="batch-info">Batch 1 of 1</div>
                <div class="batch-buttons">
                    <button class="action-btn secondary-btn" id="prev-batch-btn" disabled>Previous Batch</button>
                    <button class="action-btn" id="next-batch-btn">Next Batch</button>
                </div>
            </div>

            <!-- Review Section -->
            <div class="review-section" id="review-section">
                <div class="review-header">
                    <span>Words to Review</span>
                    <button class="action-btn secondary-btn" id="close-review-btn">Close</button>
                </div>
                <div class="review-list" id="review-list"></div>
                <div class="review-actions">
                    <button class="action-btn secondary-btn" id="practice-review-btn">Practice These Words</button>
                </div>
            </div>

            <!-- Progress Overview -->
            <div class="progress-overview" id="progress-overview">
                <div class="progress-title">Batch Progress Overview</div>
                <div class="batch-progress" id="batch-progress"></div>
                <div class="review-actions">
                    <button class="action-btn secondary-btn" id="close-progress-btn">Close</button>
                </div>
            </div>
        </main>
    </div>

    <!-- Completion Screen -->
    <div class="completion-screen" id="completion-screen">
        <div class="completion-content">
            <h2 class="completion-title">Batch Complete!</h2>
            <div class="completion-stats">
                <div class="completion-stat">
                    <span>Total Questions:</span>
                    <span id="completion-total">0</span>
                </div>
                <div class="completion-stat">
                    <span>Correct Answers:</span>
                    <span id="completion-correct">0</span>
                </div>
                <div class="completion-stat">
                    <span>Wrong Answers:</span>
                    <span id="completion-wrong">0</span>
                </div>
                <div class="completion-stat">
                    <span>Accuracy:</span>
                    <span id="completion-accuracy">0%</span>
                </div>
            </div>
            <div class="review-actions">
                <button class="action-btn secondary-btn" id="completion-review-btn">Review Wrong Answers</button>
                <button class="action-btn" id="completion-next-batch-btn">Next Batch</button>
            </div>
        </div>
    </div>

    <!-- Share Progress Modal -->
    <div class="share-modal" id="share-modal">
        <div class="share-content">
            <h2 class="share-title">Share Your Progress</h2>
            <p>Use this URL to continue your progress on another device:</p>
            <div class="share-url" id="share-url"></div>
            <div class="qr-container" id="qr-container">
                <div id="qr-code"></div>
            </div>
            <div class="share-actions">
                <button class="action-btn secondary-btn" id="close-share-btn">Close</button>
                <button class="action-btn" id="copy-url-btn">Copy URL</button>
            </div>
        </div>
    </div>

    <!-- Analysis Dashboard Modal -->
    <div class="analysis-modal" id="analysis-modal">
        <div class="analysis-content">
            <h2 class="analysis-title">Performance Analysis</h2>

            <!-- Overall Statistics -->
            <div class="analysis-stats">
                <div class="analysis-stat-card">
                    <div class="analysis-stat-number" id="analysis-total-batches">0</div>
                    <div class="analysis-stat-label">Total Batches</div>
                </div>
                <div class="analysis-stat-card">
                    <div class="analysis-stat-number" id="analysis-completed-batches">0</div>
                    <div class="analysis-stat-label">Completed Batches</div>
                </div>
                <div class="analysis-stat-card">
                    <div class="analysis-stat-number" id="analysis-overall-accuracy">0%</div>
                    <div class="analysis-stat-label">Overall Accuracy</div>
                </div>
                <div class="analysis-stat-card">
                    <div class="analysis-stat-number" id="analysis-words-to-review">0</div>
                    <div class="analysis-stat-label">Words to Review</div>
                </div>
            </div>

            <!-- Batch Performance -->
            <div class="analysis-section">
                <h3 class="analysis-section-title">Batch Performance</h3>
                <div class="batch-performance" id="batch-performance"></div>
            </div>

            <!-- Weak Words -->
            <div class="analysis-section">
                <h3 class="analysis-section-title">Words Needing Practice</h3>
                <div class="weak-words-list" id="weak-words-list"></div>
            </div>

            <div class="analysis-actions">
                <button class="action-btn secondary-btn" id="close-analysis-btn">Close</button>
                <button class="action-btn" id="export-analysis-btn">Export Data</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let originalWords = [];
        let currentBatch = 0;
        let batchSize = 50;
        let currentBatchWords = [];
        let currentIndex = 0;
        let correctAnswers = 0;
        let wrongAnswers = [];
        let totalAnswered = 0;
        let isPinyinMode = true;
        let selectedOption = null;
        let isReviewMode = false;
        let reviewWords = [];
        let completedBatches = [];
        let batchPerformance = {};
        let totalWordsCount = 0;
        let similarWordsMap = {};

        // Navigation history
        let navigationHistory = [];
        let navigationPosition = -1;

        // Progress versioning
        const PROGRESS_VERSION = 3;

        // DOM elements
        const questionEl = document.getElementById('question');
        const optionsEl = document.getElementById('options');
        const currentQuestionEl = document.getElementById('current-question');
        const correctCountEl = document.getElementById('correct-count');
        const wrongCountEl = document.getElementById('wrong-count');
        const accuracyEl = document.getElementById('accuracy');
        const progressBar = document.getElementById('progress-bar');
        const feedbackEl = document.getElementById('feedback');
        const themeToggle = document.getElementById('theme-toggle');
        const themeIcon = document.getElementById('theme-icon');
        const loadingScreen = document.getElementById('loading-screen');
        const errorMessage = document.getElementById('error-message');
        const mainContainer = document.getElementById('main-container');
        const reviewSection = document.getElementById('review-section');
        const reviewList = document.getElementById('review-list');
        const reviewWrongBtn = document.getElementById('review-wrong-btn');
        const closeReviewBtn = document.getElementById('close-review-btn');
        const practiceReviewBtn = document.getElementById('practice-review-btn');
        const completionScreen = document.getElementById('completion-screen');
        const completionTotal = document.getElementById('completion-total');
        const completionCorrect = document.getElementById('completion-correct');
        const completionWrong = document.getElementById('completion-wrong');
        const completionAccuracy = document.getElementById('completion-accuracy');
        const completionReviewBtn = document.getElementById('completion-review-btn');
        const completionNextBatchBtn = document.getElementById('completion-next-batch-btn');
        const prevBatchBtn = document.getElementById('prev-batch-btn');
        const nextBatchBtn = document.getElementById('next-batch-btn');
        const batchInfo = document.getElementById('batch-info');
        const progressOverview = document.getElementById('progress-overview');
        const progressOverviewBtn = document.getElementById('progress-overview-btn');
        const closeProgressBtn = document.getElementById('close-progress-btn');
        const batchProgress = document.getElementById('batch-progress');
        const saveProgressBtn = document.getElementById('save-progress-btn');
        const shareProgressBtn = document.getElementById('share-progress-btn');
        const shareModal = document.getElementById('share-modal');
        const shareUrlEl = document.getElementById('share-url');
        const closeShareBtn = document.getElementById('close-share-btn');
        const copyUrlBtn = document.getElementById('copy-url-btn');
        const qrCodeContainer = document.getElementById('qr-code');
        const syncIndicator = document.getElementById('sync-indicator');
        const previousQuestionBtn = document.getElementById('previous-question-btn');
        const forwardQuestionBtn = document.getElementById('forward-question-btn');
        const navigationControls = document.getElementById('navigation-controls');

        // Analysis elements
        const analysisBtn = document.getElementById('analysis-btn');
        const analysisModal = document.getElementById('analysis-modal');
        const closeAnalysisBtn = document.getElementById('close-analysis-btn');
        const exportAnalysisBtn = document.getElementById('export-analysis-btn');
        const analysisTotalBatches = document.getElementById('analysis-total-batches');
        const analysisCompletedBatches = document.getElementById('analysis-completed-batches');
        const analysisOverallAccuracy = document.getElementById('analysis-overall-accuracy');
        const analysisWordsToReview = document.getElementById('analysis-words-to-review');
        const batchPerformanceEl = document.getElementById('batch-performance');
        const weakWordsList = document.getElementById('weak-words-list');

        // ==================== VERSIONED PROGRESS SYSTEM ====================

        // Save progress with versioning
        function saveProgress() {
            const progressData = {
                version: PROGRESS_VERSION,
                timestamp: Date.now(),
                currentBatch,
                batchSize,
                currentIndex,
                correctAnswers,
                totalAnswered,
                wrongAnswers,
                isPinyinMode,
                isReviewMode,
                reviewWords,
                completedBatches,
                batchPerformance,
                totalWordsCount,
                deviceId: getDeviceId()
            };

            localStorage.setItem('hskQuizProgress', JSON.stringify(progressData));

        }

        // Load progress with version detection and conflict resolution
        function loadProgress() {
            const savedProgress = localStorage.getItem('hskQuizProgress');
            if (savedProgress) {
                try {
                    const progress = JSON.parse(savedProgress);

                    // Migrate old data if needed
                    const migratedProgress = migrateProgressData(progress);

                    // Resolve conflicts by choosing the most recent version
                    const currentProgress = getCurrentProgressData();

                    if (shouldUseNewerProgress(migratedProgress, currentProgress)) {
                        console.log('Using newer progress data from storage');
                        applyProgressData(migratedProgress);
                    } else {
                        console.log('Keeping current progress data (newer)');
                        // Current data is newer, no need to apply old data
                    }

                } catch (e) {
                    console.error('Error loading saved progress:', e);
                    resetCurrentBatch();
                    loadCurrentBatch();
                }
            }
        }

        // Migrate progress data from older versions
        function migrateProgressData(progress) {
            if (!progress.version) {
                // Version 1: Initial version
                console.log('Migrating from version 1 to version', PROGRESS_VERSION);
                return {
                    version: PROGRESS_VERSION,
                    timestamp: Date.now(),
                    currentBatch: progress.currentBatch || 0,
                    batchSize: progress.batchSize || 50,
                    currentIndex: progress.currentIndex || 0,
                    correctAnswers: progress.correctAnswers || 0,
                    totalAnswered: progress.totalAnswered || 0,
                    wrongAnswers: progress.wrongAnswers || [],
                    isPinyinMode: progress.isPinyinMode !== false,
                    isReviewMode: progress.isReviewMode || false,
                    reviewWords: progress.reviewWords || [],
                    completedBatches: progress.completedBatches || [],
                    batchPerformance: progress.batchPerformance || {},
                    totalWordsCount: progress.totalWordsCount || originalWords.length,
                    deviceId: getDeviceId()
                };
            }

            // Version 2: Add timestamp
            if (progress.version === 2) {
                console.log('Migrating from version 2 to version', PROGRESS_VERSION);
                return {
                    ...progress,
                    version: PROGRESS_VERSION,
                    timestamp: progress.timestamp || Date.now(),
                    deviceId: getDeviceId()
                };
            }

            return progress;
        }

        // Get current progress data for comparison
        function getCurrentProgressData() {
            return {
                version: PROGRESS_VERSION,
                timestamp: Date.now(),
                currentBatch,
                batchSize,
                currentIndex,
                correctAnswers,
                totalAnswered,
                wrongAnswers,
                isPinyinMode,
                isReviewMode,
                reviewWords,
                completedBatches,
                batchPerformance,
                totalWordsCount,
                deviceId: getDeviceId()
            };
        }

        // Determine which progress data is newer
        function shouldUseNewerProgress(savedProgress, currentProgress) {
            // If current session has no meaningful progress, use saved
            if (currentProgress.totalAnswered === 0 && savedProgress.totalAnswered > 0) {
                return true;
            }

            // If saved data is from a newer version, use it
            if (savedProgress.version > currentProgress.version) {
                return true;
            }

            // If versions are the same, use the one with later timestamp
            if (savedProgress.version === currentProgress.version) {
                return savedProgress.timestamp > currentProgress.timestamp;
            }

            // Otherwise keep current data
            return false;
        }

        // Apply progress data to current session
        function applyProgressData(progress) {
            currentBatch = Math.max(0, parseInt(progress.currentBatch) || 0);
            batchSize = Math.max(1, parseInt(progress.batchSize) || 50);
            currentIndex = Math.max(0, parseInt(progress.currentIndex) || 0);
            correctAnswers = Math.max(0, parseInt(progress.correctAnswers) || 0);
            totalAnswered = Math.max(0, parseInt(progress.totalAnswered) || 0);

            wrongAnswers = Array.isArray(progress.wrongAnswers) ? progress.wrongAnswers : [];
            isPinyinMode = typeof progress.isPinyinMode === 'boolean' ? progress.isPinyinMode : true;
            isReviewMode = typeof progress.isReviewMode === 'boolean' ? progress.isReviewMode : false;
            reviewWords = Array.isArray(progress.reviewWords) ? progress.reviewWords : [];
            completedBatches = Array.isArray(progress.completedBatches) ? progress.completedBatches : [];
            batchPerformance = typeof progress.batchPerformance === 'object' ? progress.batchPerformance : {};
            totalWordsCount = Math.max(0, parseInt(progress.totalWordsCount) || originalWords.length);

            // Update UI based on loaded progress
            document.getElementById('mode-pinyin').classList.toggle('active', isPinyinMode);
            document.getElementById('mode-english').classList.toggle('active', !isPinyinMode);

            if (reviewWords.length > 0) {
                reviewWrongBtn.style.display = 'block';
            }

            // Safety check: if in review mode but no review words, switch back to normal mode
            if (isReviewMode && reviewWords.length === 0) {
                isReviewMode = false;
                currentIndex = 0;
            }

            loadCurrentBatch();
            updateUI();
            updateBatchNavigation();
            updateNavigationButtons();
        }

        // Generate a semi-persistent device ID
        function getDeviceId() {
            let deviceId = localStorage.getItem('hskDeviceId');
            if (!deviceId) {
                deviceId = 'device_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                localStorage.setItem('hskDeviceId', deviceId);
            }
            return deviceId;
        }

        // Show sync indicator
        function showSyncIndicator() {
            syncIndicator.style.display = 'block';
            setTimeout(() => {
                syncIndicator.style.display = 'none';
            }, 2000);
        }

        // ==================== ENHANCED NAVIGATION SYSTEM ====================

        // Save current question to navigation history
        function saveToNavigationHistory() {
            const currentWord = isReviewMode ? reviewWords[currentIndex] : currentBatchWords[currentIndex];
            if (!currentWord) return;

            // Remove any future history if we're not at the end
            if (navigationPosition < navigationHistory.length - 1) {
                navigationHistory = navigationHistory.slice(0, navigationPosition + 1);
            }

            // Save current state
            const state = {
                word: currentWord,
                index: currentIndex,
                question: questionEl.textContent,
                options: Array.from(optionsEl.children).map(option => ({
                    innerHTML: option.innerHTML,
                    isCorrect: option.dataset.correct === 'true',
                    isSelected: option.classList.contains('selected')
                })),
                feedback: {
                    text: feedbackEl.textContent,
                    className: feedbackEl.className
                }
            };

            navigationHistory.push(state);
            navigationPosition = navigationHistory.length - 1;

            updateNavigationButtons();
        }

        // Go to previous question in navigation history
        function goToPreviousQuestion() {
            if (navigationPosition <= 0) return;

            navigationPosition--;
            const state = navigationHistory[navigationPosition];
            restoreQuestionState(state);
            updateNavigationButtons();
        }

        // Go to forward question in navigation history
        function goToForwardQuestion() {
            if (navigationPosition >= navigationHistory.length - 1) return;

            navigationPosition++;
            const state = navigationHistory[navigationPosition];
            restoreQuestionState(state);
            updateNavigationButtons();
            setTimeout(() => {
                generateQuestion();
            }, 5000);
        }

        // Restore question state from history
        function restoreQuestionState(state) {
            questionEl.textContent = state.question;
            optionsEl.innerHTML = '';

            state.options.forEach(opt => {
                const option = document.createElement('div');
                option.className = 'option';
                option.innerHTML = opt.innerHTML;
                if (opt.isCorrect) {
                    option.dataset.correct = 'true';
                }
                if (opt.isSelected) {
                    option.classList.add('selected');
                }
                // Make options read-only for navigation
                option.style.pointerEvents = 'none';
                optionsEl.appendChild(option);
            });

            feedbackEl.textContent = state.feedback.text;
            feedbackEl.className = state.feedback.className;

            // Update current index for display purposes only
            currentQuestionEl.textContent = state.index + 1;

            // Show navigation controls when navigating
            navigationControls.classList.add('visible');
        }

        // Update navigation buttons visibility and state
        function updateNavigationButtons() {
            const hasPrevious = navigationPosition > 0;
            const hasForward = navigationPosition < navigationHistory.length - 1;

            // Show/hide buttons based on availability
            if (hasPrevious || hasForward) {
                navigationControls.classList.add('visible');
            } else {
                navigationControls.classList.remove('visible');
            }

            // Update individual button states
            previousQuestionBtn.disabled = !hasPrevious;
            forwardQuestionBtn.disabled = !hasForward;

            // Show/hide buttons based on availability
            previousQuestionBtn.classList.toggle('hidden', !hasPrevious);
            forwardQuestionBtn.classList.toggle('hidden', !hasForward);
        }

        // ==================== CONSISTENT BATCHES IMPLEMENTATION ====================

        // Load vocabulary from JSON file
        async function loadVocabulary() {
            try {
                // Try multiple possible paths for GitHub Pages
                const possiblePaths = [
                    './vocabulary.json',
                    '/hsk-quiz/vocabulary.json',
                    'vocabulary.json'
                ];

                let response;
                for (const path of possiblePaths) {
                    try {
                        response = await fetch(path);
                        if (response.ok) break;
                    } catch (e) {
                        console.log(`Failed to load from ${path}, trying next...`);
                    }
                }

                if (!response || !response.ok) {
                    throw new Error(`HTTP error! status: ${response ? response.status : 'unknown'}`);
                }

                const data = await response.json();

                // Validate the data structure
                if (!Array.isArray(data.words)) {
                    throw new Error('Invalid data structure: expected array of words');
                }

                // Validate each word entry
                data.words.forEach((word, index) => {
                    if (!word.chinese || !word.pinyin || !word.english) {
                        throw new Error(`Invalid word entry at index ${index}: missing required fields`);
                    }
                });

                originalWords = data.words;
                totalWordsCount = data.totalWords || data.words.length;

                // Process the word list - SIMPLIFIED: just sort alphabetically
                arrangeWords();

                // Precompute similar words for each word
                precomputeSimilarWords();

                // Update title with level info if provided
                if (data.level) {
                    document.querySelector('.title').textContent = `HSK ${data.level} Quiz`;
                    document.querySelector('.subtitle').textContent = `${data.description || 'Match Chinese characters to pinyin and English translations'}`;
                }

                return true;
            } catch (error) {
                console.error('Failed to load vocabulary:', error);
                showError(`Failed to load vocabulary: ${error.message}. Please check that vocabulary.json exists.`);
                return false;
            }
        }

        // Process the word list - CONSISTENT ALPHABETICAL ORDERING
        function arrangeWords() {
            // Simply sort all words alphabetically by Chinese characters - NO RANDOMNESS
            originalWords.sort((a, b) => a.chinese.localeCompare(b.chinese));
            // Remove all random interleaving - just use the sorted list
        }

        // Precompute similar words for each word - DETERMINISTIC
        function precomputeSimilarWords() {
            const pinyinMap = {};

            originalWords.forEach(word => {
                // Remove tones from pinyin for better matching
                const basePinyin = word.pinyin
                    .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // Remove diacritics
                    .replace(/[0-9]/g, "") // Remove tone numbers
                    .toLowerCase();

                if (!pinyinMap[basePinyin]) {
                    pinyinMap[basePinyin] = [];
                }
                pinyinMap[basePinyin].push(word);
            });

            // For each word, find similar words - DETERMINISTIC
            originalWords.forEach(word => {
                const basePinyin = word.pinyin
                    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                    .replace(/[0-9]/g, "")
                    .toLowerCase();

                // Find words with similar pinyin (same initial or final)
                const similarWords = [];

                // Check for exact pinyin matches (without tones) - DETERMINISTIC
                if (pinyinMap[basePinyin]) {
                    pinyinMap[basePinyin].forEach(w => {
                        if (w.chinese !== word.chinese && !similarWords.some(sw => sw.chinese === w.chinese)) {
                            similarWords.push(w);
                        }
                    });
                }

                // Check for partial pinyin matches (first 2-3 characters) - DETERMINISTIC
                Object.keys(pinyinMap).forEach(pinyin => {
                    if (pinyin !== basePinyin && (
                        pinyin.startsWith(basePinyin.substring(0, 2)) ||
                        basePinyin.startsWith(pinyin.substring(0, 2))
                    )) {
                        pinyinMap[pinyin].forEach(w => {
                            if (w.chinese !== word.chinese && !similarWords.some(sw => sw.chinese === w.chinese)) {
                                similarWords.push(w);
                            }
                        });
                    }
                });

                // If we don't have enough similar words, add from beginning of list - DETERMINISTIC
                let index = 0;
                while (similarWords.length < 5 && index < originalWords.length) {
                    const candidateWord = originalWords[index];
                    if (candidateWord.chinese !== word.chinese &&
                        !similarWords.some(w => w.chinese === candidateWord.chinese)) {
                        similarWords.push(candidateWord);
                    }
                    index++;
                }

                similarWordsMap[word.chinese] = similarWords;
            });
        }

        // Load current batch words - NO SHUFFLING
        function loadCurrentBatch() {
            const startIdx = currentBatch * batchSize;
            const endIdx = Math.min(startIdx + batchSize, originalWords.length);
            currentBatchWords = originalWords.slice(startIdx, endIdx);
            // REMOVED: shuffleArray(currentBatchWords); - Batches are now consistent
        }

        // Generate incorrect options - DETERMINISTIC
        function generateIncorrectOptions(correctWord) {
            const incorrectOptions = [];
            const usedWords = new Set([correctWord.chinese]);

            // Get similar words for this word (deterministic)
            const similarWords = similarWordsMap[correctWord.chinese] || [];

            // Use similar words first (deterministic order)
            for (const similarWord of similarWords) {
                if (incorrectOptions.length >= 3) break;
                if (!usedWords.has(similarWord.chinese)) {
                    usedWords.add(similarWord.chinese);
                    incorrectOptions.push(createOptionElement(similarWord, false));
                }
            }

            // For remaining options, use deterministic selection from beginning of list
            let index = 0;
            while (incorrectOptions.length < 3 && index < originalWords.length) {
                const candidateWord = originalWords[index];

                if (!usedWords.has(candidateWord.chinese) && candidateWord.chinese !== correctWord.chinese) {
                    usedWords.add(candidateWord.chinese);
                    incorrectOptions.push(createOptionElement(candidateWord, false));
                }
                index++;
            }

            return incorrectOptions;
        }

        // Create option element with proper formatting for mobile
        function createOptionElement(word, isCorrect) {
            const option = document.createElement('div');
            option.className = 'option';
            if (isCorrect) {
                option.dataset.correct = 'true';
            }

            const isMobile = window.innerWidth <= 768;

            if (isPinyinMode) {
                // For pinyin mode, always show both pinyin and English
                const pinyinEl = document.createElement('div');
                pinyinEl.className = 'option-pinyin';
                pinyinEl.textContent = word.pinyin;

                const englishEl = document.createElement('div');
                englishEl.className = 'option-english';
                englishEl.textContent = word.english;

                option.appendChild(pinyinEl);
                option.appendChild(englishEl);
            } else {
                // For English mode, just show English
                option.textContent = word.english;
            }

            return option;
        }

        // Generate question and options with error handling - DETERMINISTIC OPTION ORDER
        function generateQuestion() {
            try {
                const totalWords = isReviewMode ? reviewWords.length : currentBatchWords.length;

                // Safety check - if no words available, reset
                if (totalWords === 0) {
                    console.warn('No words available for current mode, resetting...');
                    if (isReviewMode) {
                        // If in review mode but no review words, switch back to normal mode
                        isReviewMode = false;
                        resetCurrentBatch();
                        loadCurrentBatch();
                    } else {
                        // If in normal mode but no words, reset batch
                        resetCurrentBatch();
                        loadCurrentBatch();
                    }
                    // Try again
                    generateQuestion();
                    return;
                }

                // Check if we've completed all questions
                if (currentIndex >= totalWords) {
                    showCompletionScreen();
                    return;
                }

                // Save current state to navigation history
                saveToNavigationHistory();

                // Get current word with safety check
                let currentWord;
                if (isReviewMode) {
                    currentWord = reviewWords[currentIndex];
                } else {
                    currentWord = currentBatchWords[currentIndex];
                }

                // Validate current word
                if (!currentWord || !currentWord.chinese) {
                    console.error('Invalid current word:', currentWord);
                    // Move to next question and try again
                    currentIndex++;
                    generateQuestion();
                    return;
                }

                questionEl.textContent = currentWord.chinese;
                feedbackEl.textContent = '';
                feedbackEl.className = 'feedback';

                // Reset options
                optionsEl.innerHTML = '';

                // Create correct option
                const correctOption = createOptionElement(currentWord, true);

                // Create incorrect options using similar words (deterministic)
                const incorrectOptions = generateIncorrectOptions(currentWord);

                // Combine and use deterministic shuffle based on current word
                const allOptions = [correctOption, ...incorrectOptions];
                deterministicShuffle(allOptions, currentWord.chinese);

                // Add options to DOM
                allOptions.forEach((option) => {
                    option.addEventListener('click', selectOption);
                    option.addEventListener('touchstart', handleTouchStart, {passive: true});
                    option.addEventListener('touchend', handleTouchEnd, {passive: true});
                    optionsEl.appendChild(option);
                });

                selectedOption = null;
                updateUI();
                updateNavigationButtons();
            } catch (error) {
                console.error('Error generating question:', error);
                questionEl.textContent = 'Error loading question';
                feedbackEl.textContent = 'Please refresh the page';
                feedbackEl.className = 'feedback incorrect';
            }
        }

        // Touch handling for mobile
        function handleTouchStart(e) {
            this.style.transform = 'scale(0.98)';
        }

        function handleTouchEnd(e) {
            this.style.transform = '';
        }

        // Deterministic shuffle based on word Chinese character
        function deterministicShuffle(array, seed) {
            // Create a simple hash from the seed string
            let hash = 0;
            for (let i = 0; i < seed.length; i++) {
                hash = ((hash << 5) - hash) + seed.charCodeAt(i);
                hash = hash & hash; // Convert to 32bit integer
            }

            // Use the hash to deterministically shuffle
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.abs(hash % (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
                // Update hash for next iteration
                hash = ((hash << 5) - hash) + i;
            }
            return array;
        }

        // ==================== ANALYSIS DASHBOARD ====================

        // Show analysis dashboard
        function showAnalysisModal() {
            updateAnalysisDashboard();
            analysisModal.style.display = 'flex';
        }

        // Hide analysis dashboard
        function hideAnalysisModal() {
            analysisModal.style.display = 'none';
        }

        // Update analysis dashboard with current data
        function updateAnalysisDashboard() {
            const totalBatches = Math.ceil(originalWords.length / batchSize);

            // Update overall stats
            analysisTotalBatches.textContent = totalBatches;
            analysisCompletedBatches.textContent = completedBatches.length;
            analysisWordsToReview.textContent = reviewWords.length;

            // Calculate overall accuracy
            let totalCorrect = 0;
            let totalQuestions = 0;

            Object.keys(batchPerformance).forEach(batch => {
                totalCorrect += batchPerformance[batch].correct || 0;
                totalQuestions += batchPerformance[batch].total || 0;
            });

            // Add current batch progress if not completed
            if (!completedBatches.includes(currentBatch) && totalAnswered > 0) {
                totalCorrect += correctAnswers;
                totalQuestions += totalAnswered;
            }

            const overallAccuracy = totalQuestions > 0 ? Math.round((totalCorrect / totalQuestions) * 100) : 0;
            analysisOverallAccuracy.textContent = `${overallAccuracy}%`;

            // Update batch performance
            updateBatchPerformanceDisplay();

            // Update weak words list
            updateWeakWordsList();
        }

        // Update batch performance display
        function updateBatchPerformanceDisplay() {
            const totalBatches = Math.ceil(originalWords.length / batchSize);
            batchPerformanceEl.innerHTML = '';

            for (let i = 0; i < totalBatches; i++) {
                const batchItem = document.createElement('div');
                batchItem.className = 'batch-performance-item';

                // Determine batch status
                if (i === currentBatch) {
                    batchItem.classList.add('current');
                } else if (completedBatches.includes(i)) {
                    batchItem.classList.add('completed');
                } else if (i < currentBatch) {
                    batchItem.classList.add('in-progress');
                } else {
                    batchItem.classList.add('not-started');
                }

                // Batch number
                const batchNumber = document.createElement('div');
                batchNumber.className = 'batch-number';
                batchNumber.textContent = `Batch ${i + 1}`;

                // Accuracy
                const accuracy = document.createElement('div');
                accuracy.className = 'batch-accuracy';

                if (batchPerformance[i]) {
                    accuracy.textContent = `${batchPerformance[i].accuracy}%`;
                    accuracy.style.color = getAccuracyColor(batchPerformance[i].accuracy);
                } else if (i === currentBatch && totalAnswered > 0) {
                    const currentAccuracy = Math.round((correctAnswers / totalAnswered) * 100);
                    accuracy.textContent = `${currentAccuracy}%`;
                    accuracy.style.color = getAccuracyColor(currentAccuracy);
                } else {
                    accuracy.textContent = '-';
                    accuracy.style.color = 'var(--text-secondary)';
                }

                // Stats
                const stats = document.createElement('div');
                stats.className = 'batch-stats';

                if (batchPerformance[i]) {
                    stats.textContent = `${batchPerformance[i].correct}/${batchPerformance[i].total}`;
                } else if (i === currentBatch) {
                    stats.textContent = `${correctAnswers}/${totalAnswered}`;
                } else {
                    stats.textContent = '0/0';
                }

                batchItem.appendChild(batchNumber);
                batchItem.appendChild(accuracy);
                batchItem.appendChild(stats);

                // Click to navigate to batch
                batchItem.addEventListener('click', () => {
                    if (i !== currentBatch) {
                        currentBatch = i;
                        resetCurrentBatch();
                        loadCurrentBatch();
                        generateQuestion();
                        updateUI();
                        updateBatchNavigation();
                        hideAnalysisModal();
                        saveProgress();
                    }
                });

                batchPerformanceEl.appendChild(batchItem);
            }
        }

        // Get color based on accuracy
        function getAccuracyColor(accuracy) {
            if (accuracy >= 80) return 'var(--success)';
            if (accuracy >= 60) return 'var(--warning)';
            return 'var(--error)';
        }

        // Update weak words list
        function updateWeakWordsList() {
            weakWordsList.innerHTML = '';

            if (wrongAnswers.length === 0 && reviewWords.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.textContent = 'No words need practice yet!';
                emptyMessage.style.textAlign = 'center';
                emptyMessage.style.padding = '20px';
                emptyMessage.style.color = 'var(--text-secondary)';
                weakWordsList.appendChild(emptyMessage);
                return;
            }

            // Create a map of words and their error counts
            const wordErrors = new Map();

            // Count errors from wrongAnswers
            wrongAnswers.forEach(wrong => {
                const chinese = wrong.word.chinese;
                if (!wordErrors.has(chinese)) {
                    wordErrors.set(chinese, {
                        word: wrong.word,
                        errorCount: 0,
                        totalSeen: 0
                    });
                }
                wordErrors.get(chinese).errorCount++;
            });

            // Add review words with at least 1 error
            reviewWords.forEach(word => {
                const chinese = word.chinese;
                if (!wordErrors.has(chinese)) {
                    wordErrors.set(chinese, {
                        word: word,
                        errorCount: 1,
                        totalSeen: 1
                    });
                }
            });

            // Convert to array and sort by error count (descending)
            const weakWordsArray = Array.from(wordErrors.values())
                .sort((a, b) => b.errorCount - a.errorCount)
                .slice(0, 10); // Show top 10 weak words

            weakWordsArray.forEach(wordData => {
                const wordItem = document.createElement('div');
                wordItem.className = 'weak-word-item';

                const wordChinese = document.createElement('div');
                wordChinese.className = 'weak-word-chinese';
                wordChinese.textContent = wordData.word.chinese;

                const wordStats = document.createElement('div');
                wordStats.className = 'weak-word-stats';

                // Calculate accuracy (simplified)
                const accuracy = wordData.totalSeen > 0 ?
                    Math.round((1 - (wordData.errorCount / wordData.totalSeen)) * 100) : 0;

                wordStats.innerHTML = `
                    <span class="weak-word-accuracy">${accuracy}% accuracy</span>
                    <br>${wordData.errorCount} error${wordData.errorCount !== 1 ? 's' : ''}
                `;

                wordItem.appendChild(wordChinese);
                wordItem.appendChild(wordStats);
                weakWordsList.appendChild(wordItem);
            });
        }

        // Export analysis data
        function exportAnalysisData() {
            const analysisData = {
                timestamp: new Date().toISOString(),
                totalBatches: Math.ceil(originalWords.length / batchSize),
                completedBatches: completedBatches.length,
                batchPerformance: batchPerformance,
                reviewWordsCount: reviewWords.length,
                weakWords: Array.from(new Set(wrongAnswers.map(w => w.word.chinese).concat(reviewWords.map(w => w.chinese))))
            };

            const dataStr = JSON.stringify(analysisData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});

            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `hsk-quiz-analysis-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // ==================== EXISTING APP FUNCTIONS (UPDATED) ====================

        // Show error message
        function showError(message) {
            loadingScreen.style.display = 'none';
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        // Hide loading screen and show main content
        function showMainContent() {
            loadingScreen.style.display = 'none';
            mainContainer.style.display = 'block';
        }

        // Theme management
        function initTheme() {
            const savedTheme = localStorage.getItem('hsk-theme') || 'light';
            document.body.setAttribute('data-theme', savedTheme);
            updateThemeIcon(savedTheme);
        }

        function toggleTheme() {
            const currentTheme = document.body.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.body.setAttribute('data-theme', newTheme);
            localStorage.setItem('hsk-theme', newTheme);
            updateThemeIcon(newTheme);
        }

        function updateThemeIcon(theme) {
            themeIcon.textContent = theme === 'light' ? 'üåô' : '‚òÄÔ∏è';
        }

        // Setup event listeners
        function setupEventListeners() {
            themeToggle.addEventListener('click', toggleTheme);

            // Batch size buttons
            document.querySelectorAll('.batch-btn').forEach(btn => {
                btn.addEventListener('click', () => changeBatchSize(btn.dataset.size));
            });

            // Mode buttons
            document.getElementById('mode-pinyin').addEventListener('click', () => switchMode(true));
            document.getElementById('mode-english').addEventListener('click', () => switchMode(false));

            // Review buttons
            reviewWrongBtn.addEventListener('click', showReviewSection);
            closeReviewBtn.addEventListener('click', hideReviewSection);
            practiceReviewBtn.addEventListener('click', startReviewSession);

            // Completion screen buttons
            completionReviewBtn.addEventListener('click', showReviewSection);
            completionNextBatchBtn.addEventListener('click', startNextBatch);

            // Batch navigation
            prevBatchBtn.addEventListener('click', goToPreviousBatch);
            nextBatchBtn.addEventListener('click', goToNextBatch);

            // Progress overview
            progressOverviewBtn.addEventListener('click', showProgressOverview);
            closeProgressBtn.addEventListener('click', hideProgressOverview);

            // Save progress button
            saveProgressBtn.addEventListener('click', saveProgress);

            // Share progress button
            shareProgressBtn.addEventListener('click', showShareModal);
            closeShareBtn.addEventListener('click', hideShareModal);
            copyUrlBtn.addEventListener('click', copyShareUrl);

            // Analysis buttons
            analysisBtn.addEventListener('click', showAnalysisModal);
            closeAnalysisBtn.addEventListener('click', hideAnalysisModal);
            exportAnalysisBtn.addEventListener('click', exportAnalysisData);

            // Navigation buttons
            previousQuestionBtn.addEventListener('click', goToPreviousQuestion);
            forwardQuestionBtn.addEventListener('click', goToForwardQuestion);

            // Keyboard controls
            document.addEventListener('keydown', handleKeydown);

            // Prevent double-tap zoom on buttons for mobile
            document.addEventListener('touchstart', function() {}, {passive: true});
        }

        // Change batch size
        function changeBatchSize(size) {
            document.querySelectorAll('.batch-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.size === size);
            });

            batchSize = size === 'all' ? originalWords.length : parseInt(size);
            currentBatch = 0;
            resetCurrentBatch();
            loadCurrentBatch();
            generateQuestion();
            updateUI();
            updateBatchNavigation();
            saveProgress();
        }

        // Switch between pinyin and english mode
        function switchMode(pinyinMode) {
            isPinyinMode = pinyinMode;
            document.getElementById('mode-pinyin').classList.toggle('active', pinyinMode);
            document.getElementById('mode-english').classList.toggle('active', !pinyinMode);
            generateQuestion();
            saveProgress();
        }

        // Select an option
        function selectOption() {
            if (selectedOption) return;

            const options = document.querySelectorAll('.option');
            options.forEach(opt => opt.classList.remove('selected'));

            this.classList.add('selected');
            selectedOption = this;

            setTimeout(() => {
                checkAnswer();
            }, 300);
        }

        // Check answer
        function checkAnswer() {
            if (!selectedOption) return;

            const options = document.querySelectorAll('.option');
            options.forEach(opt => {
                opt.removeEventListener('click', selectOption);
                opt.removeEventListener('touchstart', handleTouchStart);
                opt.removeEventListener('touchend', handleTouchEnd);
                opt.style.pointerEvents = 'none';
                if (opt.dataset.correct === 'true') {
                    opt.classList.add('correct');
                }
                if (opt === selectedOption && opt.dataset.correct !== 'true') {
                    opt.classList.add('incorrect');
                }
            });

            const currentWord = isReviewMode ? reviewWords[currentIndex] : currentBatchWords[currentIndex];
            totalAnswered++;

            if (selectedOption.dataset.correct === 'true') {
                feedbackEl.innerHTML = 'üéâ Correct! Well done!';
                feedbackEl.className = 'feedback correct';
                correctAnswers++;

                // Remove from review words if it was there
                if (isReviewMode) {
                    const index = reviewWords.findIndex(w => w.chinese === currentWord.chinese);
                    if (index > -1) {
                        reviewWords.splice(index, 1);
                    }
                }
            } else {
                const correctText = isPinyinMode
                    ? `${currentWord.pinyin} - ${currentWord.english}`
                    : currentWord.english;

                feedbackEl.innerHTML = `‚ùå Incorrect.<br><strong>${correctText}</strong>`;
                feedbackEl.className = 'feedback incorrect';

                wrongAnswers.push({
                    word: currentWord,
                    selectedAnswer: selectedOption.textContent,
                    correctAnswer: correctText
                });

                // Add to review words if not already there
                if (!reviewWords.some(w => w.chinese === currentWord.chinese)) {
                    reviewWords.push(currentWord);
                }

                // Show review button if there are wrong answers
                if (reviewWords.length > 0 && !isReviewMode) {
                    reviewWrongBtn.style.display = 'block';
                }
            }

            updateUI();
            saveProgress();

            setTimeout(() => {
                nextQuestion();
            }, 2000);
        }

        // Next question
        function nextQuestion() {
            currentIndex++;
            generateQuestion();
        }

        // Update UI elements
        function updateUI() {
            currentQuestionEl.textContent = currentIndex + 1;
            correctCountEl.textContent = correctAnswers;
            wrongCountEl.textContent = wrongAnswers.length;

            const accuracy = totalAnswered > 0 ? Math.round((correctAnswers / totalAnswered) * 100) : 0;
            accuracyEl.textContent = `${accuracy}%`;

            const totalWords = isReviewMode ? reviewWords.length : currentBatchWords.length;
            const progress = Math.min(((currentIndex) / totalWords) * 100, 100);
            progressBar.style.width = `${progress}%`;
        }

        // Reset current batch
        function resetCurrentBatch() {
            currentIndex = 0;
            correctAnswers = 0;
            wrongAnswers = [];
            totalAnswered = 0;
            isReviewMode = false;
            navigationHistory = [];
            navigationPosition = -1;
            reviewWrongBtn.style.display = 'none';
            updateNavigationButtons();
        }

        // Show review section
        function showReviewSection() {
            if (reviewWords.length === 0) {
                alert("No words to review yet! Answer some questions first.");
                return;
            }

            // Populate review list
            reviewList.innerHTML = '';
            reviewWords.forEach(word => {
                const reviewItem = document.createElement('div');
                reviewItem.className = 'review-item';
                reviewItem.innerHTML = `
                    <div class="review-chinese">${word.chinese}</div>
                    <div class="review-pinyin">${word.pinyin}</div>
                    <div class="review-english">${word.english}</div>
                `;
                reviewList.appendChild(reviewItem);
            });

            // Show review section
            reviewSection.style.display = 'block';
            document.querySelector('.question-container').style.display = 'none';
        }

        // Hide review section
        function hideReviewSection() {
            reviewSection.style.display = 'none';
            document.querySelector('.question-container').style.display = 'flex';
        }

        // Start review session
        function startReviewSession() {
            if (reviewWords.length === 0) return;

            isReviewMode = true;
            currentIndex = 0;
            correctAnswers = 0;
            wrongAnswers = [];
            totalAnswered = 0;
            navigationHistory = [];
            navigationPosition = -1;

            hideReviewSection();
            document.querySelector('.question-container').style.display = 'flex';
            generateQuestion();
            updateUI();
            saveProgress();
        }

        // Show completion screen
        function showCompletionScreen() {
            // Mark batch as completed
            if (!isReviewMode) {
                completedBatches.push(currentBatch);

                // Store performance data
                const accuracy = totalAnswered > 0 ? Math.round((correctAnswers / totalAnswered) * 100) : 0;
                batchPerformance[currentBatch] = {
                    correct: correctAnswers,
                    total: currentBatchWords.length,
                    accuracy: accuracy
                };
            }

            completionTotal.textContent = isReviewMode ? reviewWords.length : currentBatchWords.length;
            completionCorrect.textContent = correctAnswers;
            completionWrong.textContent = wrongAnswers.length;

            const accuracy = totalAnswered > 0 ? Math.round((correctAnswers / totalAnswered) * 100) : 0;
            completionAccuracy.textContent = `${accuracy}%`;

            // Show or hide review button based on whether there are wrong answers
            completionReviewBtn.style.display = reviewWords.length > 0 ? 'block' : 'none';

            // Change button text for review mode
            completionNextBatchBtn.textContent = isReviewMode ? 'Back to Batch' : 'Next Batch';

            completionScreen.style.display = 'flex';
            saveProgress();
        }

        // Start next batch
        function startNextBatch() {
            completionScreen.style.display = 'none';

            if (isReviewMode) {
                // Return to regular batch mode
                isReviewMode = false;
                resetCurrentBatch();
                loadCurrentBatch();
            } else {
                // Go to next batch
                currentBatch++;
                resetCurrentBatch();
                loadCurrentBatch();
            }

            generateQuestion();
            updateUI();
            updateBatchNavigation();
            saveProgress();
        }

        // Go to previous batch
        function goToPreviousBatch() {
            if (currentBatch > 0) {
                currentBatch--;
                resetCurrentBatch();
                loadCurrentBatch();
                generateQuestion();
                updateUI();
                updateBatchNavigation();
                saveProgress();
            }
        }

        // Go to next batch
        function goToNextBatch() {
            const totalBatches = Math.ceil(originalWords.length / batchSize);
            if (currentBatch < totalBatches - 1) {
                currentBatch++;
                resetCurrentBatch();
                loadCurrentBatch();
                generateQuestion();
                updateUI();
                updateBatchNavigation();
                saveProgress();
            }
        }

        // Update batch navigation UI
        function updateBatchNavigation() {
            const totalBatches = Math.ceil(originalWords.length / batchSize);
            batchInfo.textContent = `Batch ${currentBatch + 1} of ${totalBatches} (${totalWordsCount} total words)`;

            // Enable/disable buttons
            prevBatchBtn.disabled = currentBatch === 0;
            nextBatchBtn.disabled = currentBatch === totalBatches - 1;

            // Update progress overview if visible
            if (progressOverview.style.display === 'block') {
                updateProgressOverview();
            }
        }

        // Show progress overview
        function showProgressOverview() {
            updateProgressOverview();
            progressOverview.style.display = 'block';
        }

        // Hide progress overview
        function hideProgressOverview() {
            progressOverview.style.display = 'none';
        }

        // Update progress overview
        function updateProgressOverview() {
            const totalBatches = Math.ceil(originalWords.length / batchSize);
            batchProgress.innerHTML = '';

            for (let i = 0; i < totalBatches; i++) {
                const batchItem = document.createElement('div');
                batchItem.className = 'batch-progress-item';

                if (i === currentBatch) {
                    batchItem.classList.add('current');
                } else if (completedBatches.includes(i)) {
                    batchItem.classList.add('completed');
                }

                // Add review status if there are words to review
                if (reviewWords.length > 0 && !batchItem.classList.contains('current')) {
                    batchItem.classList.add('review');
                }

                batchItem.textContent = `Batch ${i + 1}`;

                // Add performance data if available
                if (batchPerformance[i]) {
                    batchItem.title = `Accuracy: ${batchPerformance[i].accuracy}% (${batchPerformance[i].correct}/${batchPerformance[i].total})`;
                }

                batchItem.addEventListener('click', () => {
                    if (i !== currentBatch) {
                        currentBatch = i;
                        resetCurrentBatch();
                        loadCurrentBatch();
                        generateQuestion();
                        updateUI();
                        updateBatchNavigation();
                        hideProgressOverview();
                        saveProgress();
                    }
                });

                batchProgress.appendChild(batchItem);
            }
        }

        // ==================== COMPRESSION FUNCTIONS ====================

        // Convert legacy progress data to optimized format (v2)
        function convertToOptimizedFormat(legacyData) {
            try {
                const data = typeof legacyData === 'string' ? JSON.parse(legacyData) : legacyData;

                // Create optimized structure with shorter keys
                const optimized = {
                    v: 2, // version flag
                    b: data.currentBatch || 0,
                    s: data.batchSize || 50,
                    i: data.currentIndex || 0,
                    c: data.correctAnswers || 0,
                    t: data.totalAnswered || 0,
                    p: data.isPinyinMode !== false,
                    m: data.isReviewMode || false,
                    // Store only Chinese characters for review words
                    r: (data.reviewWords || []).map(w => w.chinese),
                    d: data.completedBatches || [],
                    // Wrong answers - keep all but use shorter structure
                    w: (data.wrongAnswers || []).map(wa => ({
                        c: wa.word.chinese,
                        s: wa.selectedAnswer,
                        a: wa.correctAnswer
                    })),
                    // Batch performance with shorter keys
                    bp: {},
                    ts: Date.now(),
                    tw: data.totalWordsCount || originalWords.length
                };

                // Optimize batch performance data
                if (data.batchPerformance) {
                    Object.keys(data.batchPerformance).forEach(batch => {
                        const perf = data.batchPerformance[batch];
                        optimized.bp[batch] = {
                            c: perf.correct || 0,
                            t: perf.total || 0,
                            a: perf.accuracy || 0
                        };
                    });
                }

                return JSON.stringify(optimized);
            } catch (error) {
                console.error('Error converting to optimized format:', error);
                return legacyData; // Fallback to original data
            }
        }

        // Convert optimized format back to legacy format for loading
        function convertToLegacyFormat(optimizedData, originalWords) {
            try {
                const data = typeof optimizedData === 'string' ? JSON.parse(optimizedData) : optimizedData;

                if (data.v !== 2) {
                    return JSON.stringify(data); // Already in legacy format
                }

                // Reconstruct full objects from Chinese characters
                const legacy = {
                    currentBatch: data.b || 0,
                    batchSize: data.s || 50,
                    currentIndex: data.i || 0,
                    correctAnswers: data.c || 0,
                    totalAnswered: data.t || 0,
                    isPinyinMode: data.p !== false,
                    isReviewMode: data.m || false,
                    // Reconstruct reviewWords with full objects
                    reviewWords: (data.r || []).map(chinese =>
                        originalWords.find(w => w.chinese === chinese) || { chinese }
                    ).filter(w => w.chinese),
                    completedBatches: data.d || [],
                    // Reconstruct wrongAnswers with full objects
                    wrongAnswers: (data.w || []).map(wa => {
                        const word = originalWords.find(w => w.chinese === wa.c) || { chinese: wa.c };
                        return {
                            word: word,
                            selectedAnswer: wa.s,
                            correctAnswer: wa.a
                        };
                    }),
                    batchPerformance: {},
                    totalWordsCount: data.tw || originalWords.length
                };

                // Reconstruct batch performance
                if (data.bp) {
                    Object.keys(data.bp).forEach(batch => {
                        const perf = data.bp[batch];
                        legacy.batchPerformance[batch] = {
                            correct: perf.c || 0,
                            total: perf.t || 0,
                            accuracy: perf.a || 0
                        };
                    });
                }

                return JSON.stringify(legacy);
            } catch (error) {
                console.error('Error converting to legacy format:', error);
                return JSON.stringify(optimizedData); // Fallback
            }
        }

        // Detect data format version
        function detectDataFormat(data) {
            try {
                const parsed = typeof data === 'string' ? JSON.parse(data) : data;
                return parsed.v === 2 ? 'optimized' : 'legacy';
            } catch (error) {
                return 'legacy'; // Assume legacy format on error
            }
        }

        // UTF-8 safe encoding/decoding functions
        function encodeUTF8(str) {
            try {
                if (typeof TextEncoder !== 'undefined') {
                    const encoder = new TextEncoder();
                    const data = encoder.encode(str);
                    return btoa(String.fromCharCode(...data));
                }
            } catch (e) {
                console.log('TextEncoder not available, using fallback');
            }
            return btoa(unescape(encodeURIComponent(str)));
        }

        function decodeUTF8(str) {
            try {
                if (typeof TextDecoder !== 'undefined') {
                    const binaryStr = atob(str);
                    const bytes = new Uint8Array(binaryStr.length);
                    for (let i = 0; i < binaryStr.length; i++) {
                        bytes[i] = binaryStr.charCodeAt(i);
                    }
                    const decoder = new TextDecoder();
                    return decoder.decode(bytes);
                }
            } catch (e) {
                console.log('TextDecoder not available, using fallback');
            }
            return decodeURIComponent(escape(atob(str)));
        }

        // Updated share progress function with compression
        function showShareModal() {
            const progressData = getCurrentProgressData();

            // Add device info for better conflict resolution
            progressData.deviceId = getDeviceId();
            progressData.appVersion = '1.0.0';

            try {
                // Convert to optimized format for sharing
                const optimizedData = convertToOptimizedFormat(JSON.stringify(progressData));

                // Compress using LZ-String
                const compressedData = LZString.compressToBase64(optimizedData)
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=+$/, '');

                const shareUrl = `${window.location.origin}${window.location.pathname}?p=${compressedData}`;

                // Display URL with version info
                shareUrlEl.textContent = `${shareUrl}\n\nVersion: ${progressData.version} | Last Updated: ${new Date(progressData.timestamp).toLocaleString()}`;

                // Generate QR code
                generateQRCode(shareUrl);

                // Show modal
                shareModal.style.display = 'flex';
            } catch (error) {
                console.error('Error generating share URL:', error);
                // Fallback to old method without compression
                try {
                    const encodedData = encodeUTF8(JSON.stringify(progressData)).replace(/=/g, '');
                    const shareUrl = `${window.location.origin}${window.location.pathname}?progress=${encodedData}`;
                    shareUrlEl.textContent = shareUrl;
                    generateQRCode(shareUrl);
                    shareModal.style.display = 'flex';
                } catch (fallbackError) {
                    alert('Error generating share URL. Please try again.');
                }
            }
        }

        // Updated load progress from URL function with decompression and format detection
        function loadProgressFromURL() {
            const urlParams = new URLSearchParams(window.location.search);

            // Try new compressed format first
            let progressParam = urlParams.get('p');
            if (progressParam) {
                try {
                    // Add padding back if needed
                    let data = progressParam.replace(/-/g, '+').replace(/_/g, '/');
                    while (data.length % 4) {
                        data += '=';
                    }

                    // Decompress
                    const decompressedData = LZString.decompressFromBase64(data);
                    if (!decompressedData) {
                        throw new Error('Decompression failed');
                    }

                    // Detect format and convert to legacy if needed
                    const format = detectDataFormat(decompressedData);
                    let progressData;

                    if (format === 'optimized') {
                        progressData = convertToLegacyFormat(decompressedData, originalWords);
                    } else {
                        progressData = decompressedData;
                    }

                    if (progressData && confirm('Load progress from URL? This will replace your current progress.')) {
                        localStorage.setItem('hskQuizProgress', progressData);
                        // Clean URL
                        window.history.replaceState({}, '', window.location.pathname);
                        alert('Progress loaded successfully! Page will reload.');
                        location.reload();
                    }
                } catch (e) {
                    console.error('Error loading compressed progress from URL:', e);
                }
            }

            // Fallback to old format (for backward compatibility with old shares)
            else {
                const progressParam = urlParams.get('progress');
                if (progressParam) {
                    try {
                        // Add padding if needed
                        let data = progressParam;
                        while (data.length % 4) {
                            data += '=';
                        }

                        const progressData = decodeUTF8(data);

                        if (progressData && confirm('Load progress from URL? This will replace your current progress.')) {
                            localStorage.setItem('hskQuizProgress', progressData);
                            // Clean URL
                            window.history.replaceState({}, '', window.location.pathname);
                            alert('Progress loaded successfully! Page will reload.');
                            location.reload();
                        }
                    } catch (e) {
                        console.error('Error loading progress from URL:', e);
                    }
                }
            }
        }

        // Updated QR code generation for smaller codes
        function generateQRCode(text) {
            qrCodeContainer.innerHTML = '';

            try {
                // Use lower error correction for smaller QR codes
                const typeNumber = 0;
                const errorCorrectionLevel = 'L'; // Low error correction = smaller code
                const qr = qrcode(typeNumber, errorCorrectionLevel);
                qr.addData(text);
                qr.make();

                // Create smaller QR code
                const qrImage = qr.createImgTag(3, 0); // Reduced from 4 to 3
                qrCodeContainer.innerHTML = qrImage;
            } catch (error) {
                console.error('Error generating QR code:', error);
                qrCodeContainer.innerHTML = '<p style="color: var(--error);">QR code generation failed</p>';
            }
        }

        function hideShareModal() {
            shareModal.style.display = 'none';
        }

        function copyShareUrl() {
            const url = shareUrlEl.textContent;
            navigator.clipboard.writeText(url).then(() => {
                copyUrlBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyUrlBtn.textContent = 'Copy URL';
                }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = url;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                copyUrlBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyUrlBtn.textContent = 'Copy URL';
                }, 2000);
            });
        }

        // Keyboard controls
        function handleKeydown(e) {
            if (e.key >= '1' && e.key <= '4') {
                const optionIndex = parseInt(e.key) - 1;
                const options = document.querySelectorAll('.option');
                if (options[optionIndex] && !selectedOption) {
                    selectOption.call(options[optionIndex]);
                }
            }
        }

        // Shuffle array (kept for potential future use, but not used in current implementation)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Initialize the app
        async function init() {
            initTheme();
            setupEventListeners();

            // Load vocabulary
            const success = await loadVocabulary();

            if (success) {
                loadCurrentBatch();
                loadProgress(); // Load saved progress after vocabulary is loaded
                loadProgressFromURL(); // Check for progress in URL
                generateQuestion();
                updateUI();
                updateBatchNavigation();
                updateNavigationButtons();
                showMainContent();
            }
        }

        // Start the app
        init();
    </script>
</body>
</html>